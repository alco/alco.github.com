<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <title>Introducing Elixir</title>

    <link href='http://fonts.googleapis.com/css?family=Libre+Baskerville:400,700' rel='stylesheet' type='text/css'>

    <style type="text/css">
      body {
        font-family: "Verdana", sans-serif; /*'Libre Baskerville', serif;*/
        font-size: 16pt;
      }

      p, ul, ol {
        font-size: 20pt;
      }

      .small {
        font-size: 16pt;
      }

      .block {
        line-height: 160%;
      }

      li {
        line-height: 140%;
      }

      .remark-slide .remark-slide-content {
        padding: 0pt 60pt 0pt 60pt;
      }

      .invisible {
        color: white;
      }

      .code-bg {
        background: #f0f0f0;
        padding: 10px;
      }

      a {
        text-decoration: none;
      }

      a:visited {
        color: #00e;
      }
    </style>
  </head>

  <body>

    <textarea id="source" readonly>

class: center, middle

![img](data/logo.png)

---

class: center, middle

# Introducing Elixir

<big>
Alexei Sholik
</big>

<small>
  <pre>August 3, 2013 @ [kievfprog.net](http://kievfprog.net)</pre>
</small>

???

This presentation's url: http://alexeisholik.com/elixir-talk

---

```erlang
lists:map(fun A -> ... end, List).
dict:map(fun K, V -> ... end, Dict).
gb_trees:map(fun K, V -> ... end, Tree).
lists:map(fun A -> ... end, sets:to_list(Set)).
```
---

# Agenda

1. What is Elixir?

2. A brief history

3. The basics
 * modules
 * pattern matching
 * recursion

4. Going deeper
 * macros
 * interesting projects

5. How to get started

---

class: middle

# What is Elixir?

---

# What is Elixir?

## 1. Erlang VM

---

# What is Elixir?

## 1. Erlang VM

## 2. Less code

---

class: center, middle

# What is Elixir?

## 1. Erlang VM

## 2. Less code

## 3. More fun

---

# Under the hood

Elixir compiles to the same BEAM byte code as Erlang.

<pre>
   +--------+   +--------+
   | Erlang |   | Elixir |
   +--------+   +--------+
       ||           ||
       \/           \/
     +-----------------+
     | .beam byte code |
     +-----------------+
             ||
             \/
+---------------------------+
| BEAM emulator (Erlang VM) |
+---------------------------+
</pre>

---

# Elixir ⟺ Erlang

---

# Elixir ⟺ Erlang

* Same byte code

---
# Elixir ⟺ Erlang

* Same byte code

* Same VM


---

# Elixir ⟺ Erlang

* Same byte code

* Same VM

* Same runtime environment

---

# Elixir ⟺ Erlang

* Same byte code

* Same VM

* Same runtime environment

* Seamless interoperability

---

# Elixir ⟺ Erlang

* Same byte code

* Same VM

* Same runtime environment

* Seamless interoperability

```
iex(1)> :erlang.list_to_integer '123'
123
```

---

# Elixir ⟺ Erlang

* Same byte code

* Same VM

* Same runtime environment

* Seamless interoperability

```
iex(1)> :erlang.list_to_integer '123'
123
```

```
1> 'Elixir.Enum':map([1,2,3], fun(X) -> X * X end).
[1,4,9]
```

---

# Elixir ⟺ Erlang

Let's play together.

![sandbox](data/sandbox.jpg)

???

Image originally from http://upload.wikimedia.org/wikipedia/commons/d/df/Our_Community_Place_Sandbox.jpg.

---

class: middle

# Why Elixir?

---

# Why Elixir?

* modern syntax (less clunky than Erlang)

---

# Why Elixir?

* modern syntax (less clunky than Erlang)

* improved semantics (protocols, everything is an expression, lexically scoped aliases)

---

# Why Elixir?

* modern syntax (less clunky than Erlang)

* improved semantics (protocols, everything is an expression, lexically scoped aliases)

* user friendly (exceptions; interactive help)

---

# Why Elixir?

* modern syntax (less clunky than Erlang)

* improved semantics (protocols, everything is an expression, lexically scoped aliases)

* user friendly (exceptions; interactive help)

* consistent standard library

---

# Why Elixir?

* modern syntax (less clunky than Erlang)

* improved semantics (protocols, everything is an expression, lexically scoped aliases)

* user friendly (exceptions; interactive help)

* consistent standard library

* less boilerplate (via macros)

---

# Why Elixir?

* modern syntax (less clunky than Erlang)

* improved semantics (protocols, everything is an expression, lexically scoped aliases)

* user friendly (exceptions; interactive help)

* consistent standard library

* less boilerplate (via macros)

* better code maintainability

---

# Why Elixir?

* modern syntax (less clunky than Erlang)

* improved semantics (protocols, everything is an expression, lexically scoped aliases)

* user friendly (exceptions; interactive help)

* consistent standard library

* less boilerplate (via macros)

* better code maintainability

* a whole new community of enthusiasts

---

# Why Elixir?

* modern syntax (less clunky than Erlang)

* improved semantics (protocols, everything is an expression, lexically scoped aliases)

* user friendly (exceptions; interactive help)

* consistent standard library

* less boilerplate (via macros)

* better code maintainability

* a whole new community of enthusiasts

* it is fun!

---

# A glimpse of Elixir

```
defmodule Helloer do
  @doc "Waits for a messages and sends back a reply"
  def hola do
    receive do
      {sender, msg} ->
        sender <- { :ok, "Received: '#{msg}'. Thank you!" }
    end
  end
end

helloer_pid = spawn(Helloer, :hola, [])

helloer_pid <- {self, "Here's a message for you!"}
receive do
  { :ok, msg } -> IO.puts msg
end
```

<pre class="code-bg">
$ elixir hello.ex
Received: 'Here's a message for you!'. Thank you!
</pre>

???

Code sample from http://benjamintanweihao.github.io/blog/2013/07/04/elixir-for-the-lazy-impatient-and-busy-part-3-processes-101

---

class: middle

# A brief history

---

# A brief history (1)

Elixir started as a learning exercise by José Valim – a well-known contributor to Ruby on Rails.

---

# A brief history (1)

Elixir started as a learning exercise by José Valim – a well-known contributor to Ruby on Rails.

## January–March 2011

* Initial prototype. Goal: Ruby on Erlang, with objects and stuff
* Didn't work out as expected

---

# A brief history (1)

Elixir started as a learning exercise by José Valim – a well-known contributor to Ruby on Rails.

## January–March 2011

* Initial prototype. Goal: Ruby on Erlang, with objects and stuff
* Didn't work out as expected

## Early 2012

* A new attempt is underway. Goals:
  * stay close to the host VM's semantics
  * no: OOP; yes: runtime polymorphism
  * minimum overhead

---

# A brief history (2)

## Spring 2012

* Healthy language growth
* 2-3 active contributors
* ~20 people in #elixir-lang IRC room
* mailing list with ~1 post per week

---

# A brief history (2)

## Spring 2012

* Healthy language growth
* 2-3 active contributors
* ~20 people in #elixir-lang IRC room
* mailing list with ~1 post per week

## 2013

* The language has grown a lot (15K SLOC vs 6K in 2012)
* ~10 active contributors + many casual PRs
* ~110 people in #elixir-lang
* for comparison: ~350 in #erlang, ~250 in #rust, ~750 in #go-nuts

---

# My involvement

* First came to Elixir in March 2012 (via [@darkproger](https://twitter.com/darkproger))

* Was actively contributing for a few months, then stopped

* Resumed my contributions one year later (this spring)

* Have a pretty good grasp of how it works and where it's headed

---

# Shameless

![contributors graph](data/shameless.png)

---

# Elixir development status (1)

* Overview

![commits summary](data/commits.png)

---

# Elixir development status (1)

* Overview

![commits summary](data/commits.png)

* If you're really curious

![language summary](data/langs.png)

---

# Elixir development status (2)

* The project is still young

  * version 0.10
  * not too many pure Elixir libraries
  * missing advanced documentation
  * some tools are still WIP

---

# Elixir development status (2)

* The project is still young
  * version 0.10
  * not too many pure Elixir libraries
  * missing advanced documentation
  * some tools are still WIP

* But it is quite stable
  * easy to start with
  * seamless interop with Erlang libs and tools
  * people already use it in production
  * very few user-level changes in the language expected (so your code won't break)
  * though the internals are still actively evolving

---

class: middle

# The basics

---

# A taste of Elixir (1)

```
defmodule Demo do
  @event "kievfprog"

  def greet_people([]) do
    IO.puts "The room is empty"
  end

  def greet_people([person]) do
    IO.puts "Hi #{person}. Welcome to #{@event}"
  end

  def greet_people(list) when is_list(list) do
    list
    |> Enum.map(fn(x) -> String.capitalize(x) end)
    |> Enum.reduce("", fn(person, acc) ->
      IO.puts "Hi #{person}#{acc}."
      " too"
    end)
    :ok
  end
end
```

---

# A taste of Elixir (2)

```javascript
iex(1)> Demo.greet_people []
The room is empty
:ok
```
```
def greet_people([]) do
  IO.puts "The room is empty"
end
```

---

# A taste of Elixir (2)

```javascript
iex(1)> Demo.greet_people []
The room is empty
:ok
```
```
def greet_people([]) do
  IO.puts "The room is empty"
end
```
<hr/>
```javascript
iex(2)> Demo.greet_people ["Alex"]
Hi Alex. Welcome to kievfprog
:ok
```
```
@event "kievfprog"
def greet_people([person]) do
  IO.puts "Hi #{person}. Welcome to #{@event}"
end
```

---

# A taste of Elixir (3)

```javascript
iex(3)> Demo.greet_people ["nick", "mary", "peter"]
Hi Nick.
Hi Mary too.
Hi Peter too.
:ok
```
```
def greet_people(list) when is_list(list) do
  list
  |> Enum.map(fn(x) -> String.capitalize(x) end)
  |> Enum.reduce("", fn(person, acc) ->
    IO.puts "Hi #{person}#{acc}."
    " too"
  end)
  :ok
end
```

---

# Pipe breakdown (1)

```
def greet_people(list) when is_list(list) do
  alias String, as: S

  list
  |> Enum.map(fn(x) -> S.capitalize(x) end)
  |> Enum.map(fn(x) -> S.slice(x, 0, S.length(x)-1) end)
  |> Enum.reduce("", fn(person, acc) ->
    IO.puts "Hi #{person}#{acc}."
    " too"
  end)
  :ok
end
```

---

# Pipe breakdown (2)

```
def greet_people(list) when is_list(list) do
  alias String, as: S

  list = Enum.map list, fn(x) -> S.capitalize(x) end
  list
  |> Enum.map(fn(x) -> S.slice(x, 0, S.length(x)-1) end)
  |> Enum.reduce("", fn(person, acc) ->
    IO.puts "Hi #{person}#{acc}."
    " too"
  end)
  :ok
end
```

---

# Pipe breakdown (3)

```
def greet_people(list) when is_list(list) do
  alias String, as: S

  list = Enum.map list, fn(x) -> S.capitalize(x) end
  list = Enum.map list, fn(x) -> S.slice(x, 0, S.length(x)-1) end
  list
  |> Enum.reduce("", fn(person, acc) ->
    IO.puts "Hi #{person}#{acc}."
    " too"
  end)
  :ok
end
```

---

# Pipe breakdown (4)

```
def greet_people(list) when is_list(list) do
  alias String, as: S

  list = Enum.map list, fn(x) -> S.capitalize(x) end
  list = Enum.map list, fn(x) -> S.slice(x, 0, S.length(x)-1) end

  Enum.reduce list, "", fn(person, acc) ->
    IO.puts "Hi #{person}#{acc}."
    " too"
  end
  :ok
end
```

---

# Pipe breakdown (5)

```
def greet_people(list) when is_list(list) do
  alias String, as: S

  list = Enum.map list, S.capitalize(&1)
  list = Enum.map list, fn(x) -> S.slice(x, 0, S.length(x)-1) end

  Enum.reduce list, "", fn(person, acc) ->
    IO.puts "Hi #{person}#{acc}."
    " too"
  end
  :ok
end
```

---

# No "variable ladder"

* Erlang

```
X1 = some_func(X),
X2 = another_func(X1),
X_final = final_func(X2).
```

* Elixir

```
x = some_func(x)
x = another_func(x)
x = final_func(x)
```
or
```
x = x
|> some_func
|> another_func
|> final_func
```

---

# The "curry" operator (1)

Simplifies some common cases of function currying.

```
iex(1)> Enum.all? [:a, :b, :c], is_atom(&1)
true

iex(2)> Enum.map ["a", "B", "c"], String.upcase &1
["A", "B", "C"]

iex(3)> Enum.map_join([1, 2, 3], " < ", &1 * 2)
"2 < 4 < 6"

iex(4)> Enum.min [1, 2, 3], -&1
3

iex(5)> Enum.sort [1, 2, 3], &1 < &2
[1, 2, 3]

iex(6)> Enum.sort [1, 2, 3], &2 < &1
[3, 2, 1]
```

---

# The "curry" operator (2)

Be careful.

```
iex(1)> &1 + &2      # == fn(x, y) -> x + y end
function(Kernel.+/2)

iex(2)> &1 + &2 + &3
** (SyntaxError) iex:2: partial variable &3 cannot
                        be defined without &1
```

---

# The "curry" operator (2)

Be careful.

```
iex(1)> &1 + &2      # == fn(x, y) -> x + y end
function(Kernel.+/2)

iex(2)> (&1 + &2) + &3
** (SyntaxError) iex:2: partial variable &3 cannot
                        be defined without &1
```

---

# The "curry" operator (2)

Be careful.

```
iex(1)> &1 + &2      # == fn(x, y) -> x + y end
function(Kernel.+/2)

iex(2)> (&1 + &2) + &3
** (SyntaxError) iex:2: partial variable &3 cannot
                        be defined without &1
```

There is a [pending proposal](https://groups.google.com/forum/#!topic/elixir-lang-core/QIA4kvWzjng)
for making it more flexible (and hopefully less confusing).

```
iex(1)> f = &( &1 + &2 + &3)
#Function<erl_eval.6.17052888>
iex(2)> f.(10, 20, 30)
60

iex(3)> &Enum.map(&1, some_func)
#Function<erl_eval.6.17052888>
```

---

# The "curry" operator (3)

A "curried" function is like an anonymous function, often faster.

```
iex(1)> f = fn(x) -> IO.puts x end
#Function<erl_eval.6.17052888>

iex(2)> f.("hello")     # == apply(f, ["hello"])
hello                   # 2 calls
:ok
#Function<erl_eval.6.17052888>

iex(3)> f = IO.puts &1
function(IO.puts/1)

iex(4)> f.("hello")     # == apply(IO, :puts, ["hello"])
hello                   # 1 call
:ok
```

---

# Anonymous functions (1)

Effectively live in a separate namespace.

```
iex(1)> puts = fn(x) -> IO.puts String.upcase(x) end
#Function<erl_eval.6.17052888>

iex(2)> import IO
nil

iex(3)> puts "hello"
hello
:ok

iex(4)> puts.("hello")
HELLO
:ok
```

---

# Anonymous functions (2)

Can have multiple clauses.

```
iex(1)> f = fn
...(1)>   lst when is_list(lst) -> Enum.map lst, -&1
...(1)>   [] -> 0
...(1)>   x -> -x
...(1)> end
#Function<erl_eval.6.17052888>

iex(2)> f.(1)
-1

iex(3)> f.([1,2,3])
[-1, -2, -3]
```

---

# Macros lurking

```
iex(1)> function(IO.puts/1)
function(IO.puts/1)

iex(2)> IO.puts/1
** (UndefinedFunctionError) undefined function: IO.puts/0
```

---

# Macros lurking

```
iex(1)> function(IO.puts/1)
function(IO.puts/1)

iex(2)> IO.puts() / 1
** (UndefinedFunctionError) undefined function: IO.puts/0
```

---

# Macros lurking

```
iex(1)> function(IO.puts/1)
function(IO.puts/1)

iex(2)> IO.puts() / 1
** (UndefinedFunctionError) undefined function: IO.puts/0

iex(3)> h function
* defmacro function(args)

Construct an anonymous function based on the given expression
or retrieve an existing one.
...
```

---

class: middle

# Pattern matching

---

# Pattern matching (1)

There is no assignment in Elixir: the equals sign (`=`) is called a "match" operator.

```
iex(1)> a = 1
1
iex(2)> 1 = a
1
iex(3)> 2 = a
** (MatchError) no match of right hand side value: 1

iex(4)> a = 2
2

iex(5)> [a | b] = [1, 2, 3]
[1, 2, 3]
iex(6)> a
1
iex(7)> b
[2, 3]
```

---

# Pattern matching (2)

When you want to match the value of a variable instead of rebinding it, use `^`.

```
iex(1)> a = 1
1

iex(2)> [^a | _] = [:a, :b]
** (MatchError) no match of right hand side value: [:a, :b]

iex(3)> [a | _] = [:a, :b]
[:a, :b]

iex(4)> a
:a
```

---

# Pattern matching (3)

Variables are only rebound on the left hand side. No need to use `^` to the right of `=`.

```
iex(1)> a = :atom
:atom

iex(2)> :atom = a
:atom

iex(3)> :b = a
** (MatchError) no match of right hand side value: :atom

iex(4)> ^a = :b
** (MatchError) no match of right hand side value: :b

iex(5)> a = :b
:b
```

---

# Pattern matching (4)

Lists:

```
iex(1)> [h | t] = [1]
[1]
iex(2)> t
[]
iex(3)> [_ | t] = [1, 2, 3]
[1, 2, 3]
iex(4)> t
[2, 3]

iex(5)> [:a, :b, _] = [1, 2, 3]
** (MatchError) no match of right hand side value: [1, 2, 3]

iex(6)> [a, a, _] = [1, 2, 3]
** (MatchError) no match of right hand side value: [1, 2, 3]
iex(6)> [a, a, _] = [1, 1, 3]
[1, 1, 3]
iex(7)> a
1
```

---

# Pattern matching (5)

Tuples:

```
iex(1)> { tag, value } = { :event, "kievfprog" }
{:event, "kievfprog"}
iex(2)> { :event, _ } = { :event, "kievfprog" }
{:event, "kievfprog"}
iex(3)> { :event, _ } = { :error, "no event" }
** (MatchError) no match of right hand side value:
                {:error, "no event"}

iex(4)> { :event, _ } = :error
** (MatchError) no match of right hand side value:
                :error

iex(5)> { :ok, file } = File.open "nonexistent"
** (MatchError) no match of right hand side value:
                {:error, :enoent}

iex(6)> file = File.open! "nonexistent"
** (File.Error) could not open nonexistent: no such file
                or directory
```

---

# Pattern matching (6)

Keyword lists:

```
iex(1)> l = [type: :person, age: 23, name: "Alex"]
[type: :person, age: 23, name: "Alex"]

iex(2)> [type: :person, age: _, name: name] = l
[type: :person, age: 23, name: "Alex"]

iex(3)> name
"Alex"

iex(4)> [type: :person, age: 30, name: name] = l
** (MatchError) no match of right hand side value:
                [type: :person, age: 23, name: "Alex"]
```

---

# Pattern matching (6)

Keyword lists:

```
iex(1)> l = [type: :person, age: 23, name: "Alex"]
[type: :person, age: 23, name: "Alex"]

iex(2)> [type: :person, age: _, name: name] = l
[type: :person, age: 23, name: "Alex"]

iex(3)> name
"Alex"

iex(4)> [type: :person, age: 30, name: name] = l
** (MatchError) no match of right hand side value:
                [type: :person, age: 23, name: "Alex"]
```

A keyword list is a list of tuples.

```
iex(1)> inspect [age: 23, gender: :male], raw: true
"[{:age, 23}, {:gender, :male}]"
```

---

# Pattern matching (7)

Binaries:

```
iex(1)> a = "ßtring" <> "concat"
"ßtringconcat"
iex(2)> "ßtr" <> b = a
"ßtringconcat"
iex(3)> b
"ingconcat"

iex(4)> << a::utf8, _::binary >> = a
"ßtringconcat"
iex(5)> { a, <<a>> }
{223, <<223>>}
iex(6)> { <<a::utf8>>, "\x{df}" }  # 0xDF == 223
{"ß", "ß"}

iex(7)> <<a, b, _::binary>> = "épsilon"
"épsilon"
iex(8)> { a, b, list_to_binary([a, b]) }
{195, 169, "é"}
```

---

# Pattern matching (8)

Pattern matching is ubiquitous in Elixir.


```
case String.to_integer str do
  { num, _ } -> num
  :error     -> 0
end

# ---

{ :ok, items } = File.ls("/")

# ---

count = fn
  []      -> 0
  [_]     -> 1
  [_, _]  -> 2
  [_|_]=l -> length(l)
end

```

---

# Pattern matching (9)

It is very useful in `case` expressions and function definitions.

```
defmodule M do
  def test(x) do
    case x do
      x when is_list(x)   -> "list"
      { _, _ }            -> "a pair"
      1234                -> "one two three four"
      x when is_number(x) -> "some other number"
      _                   -> "something else"
    end
  end
end
```

---

# Pattern matching (9)

It is very useful in `case` expressions and function definitions.

```
defmodule M do
  def test(x) do
    case x do
      x when is_list(x)   -> "list"
      { _, _ }            -> "a pair"
      1234                -> "one two three four"
      x when is_number(x) -> "some other number"
      _                   -> "something else"
    end
  end
end
```

```
M.test 1234   # "one two three four"
M.test 0.0    # "some other number"
M.test []     # "list"
M.test {}     # "something else"
```

---

# Pattern matching (10)

Another way to write the same function.

```
defmodule M do
  def test([_|_]), do: "list"
  def test([]),    do: "empty list"

  def test({ _, _ }), do: "a pair"

  def test(1234),     do: "one two three four"
  def test(x) when is_number(x),
                      do: "some other number"

  def test(_), do: "something else"
end
```

---

class: middle

# > `Calendar` module

---

class: middle

# Modules

---

# Modules (1)

Modules are the building blocks of Elixir applications.

---

# Modules (1)

Modules are the building blocks of Elixir applications.

Modules contain functions and module attributes (no state).

---

# Modules (1)

Modules are the building blocks of Elixir applications.

Modules contain functions and module attributes (no state).

A module is a minimum unit of compiled code.

---

# Modules (2)

```
# math.ex
defmodule Math do
  @moduledoc "A few math functions"

  def square(num) when is_number(num) do
    num * num
  end

  def square(nums) when is_list(nums) do
    Enum.map nums, square &1
  end
end
```

---

# Modules (2)

```
# math.ex
defmodule Math do
  @moduledoc "A few math functions"

  def square(num) when is_number(num) do
    num * num
  end

  def square(nums) when is_list(nums) do
    Enum.map nums, square &1
  end
end
```

```
$ elixirc math.ex
Compiled math.ex

$ ls
Elixir.Math.beam     math.ex
```

---

# Modules (3)

Now let's fire up the interactive shell.

```
iex(1)> Math.square 4
16

iex(2)> Math.square [4, 5, 6]
[16, 25, 36]

iex(3)> h Math
# Math

A few math functions
:ok

iex(4)> Math.__info__ :moduledoc
{1, "A few math functions"}

iex(5)> Math.__info__ :functions
[square: 1]
```

---

# Modules (4)

Modules are loaded dynamically.

```
iex(1)> Math.square 1
# 1. The VM loads Math from Elixir.Math.beam if not already
# 2. Checks if Math defines square/1
# 3. Invokes Math.square/1
1
```

---

# Modules (4)

Modules are loaded dynamically.

```
iex(1)> Math.square 1
# 1. The VM loads Math from Elixir.Math.beam if not already
# 2. Checks if Math defines square/1
# 3. Invokes Math.square/1
1
```

Can be preloaded manually.

```
iex(1)> Code.require_file "math.ex"
[{Math,
  <<70, 79, 82, 49, 0, 0, 8, 196, 66, 69, 65, ...>>}]

iex(2)> m
...
Macro.Env    .../lib/elixir/ebin/Elixir.Macro.Env.beam
Math         .../home/projects/elixir-talk/math.ex      # <--
Module       .../lib/elixir/ebin/Elixir.Module.beam
...
```

---

# Modules (5)

A .ex file is like a script (a recipe) that is fed to the compiler.

---

# Modules (5)

A .ex file is like a script (a recipe) that is fed to the compiler.

The compiler evaluates each expression in the script.

---

# Modules (5)

A .ex file is like a script (a recipe) that is fed to the compiler.

The compiler evaluates each expression in the script.

For example, `defmodule` evaluates to a new compiled module which is written into the corresponding .beam file.

---

# Modules (6)

Defining a module in IEx.

```
iex(1)> defmodule Test do
...(1)>   def func do
...(1)>     :test
...(1)>   end
...(1)> end
{:module, Test,
 <<70, 79, 82, 49, 0, 0, 6, 248, 66, 69, 65, ...>>,
 {:func, 0}}
```

---

# Modules (6)

Defining a module in IEx.

```
iex(1)> defmodule Test do
...(1)>   def func do
...(1)>     :test
...(1)>   end
...(1)> end
{:module, Test,
 <<70, 79, 82, 49, 0, 0, 6, 248, 66, 69, 65, ...>>,
 {:func, 0}}
```

Remember: everything in Elixir is an expression.

---

# Modules (7)

```
# mod.ex
defmodule M do
  IO.puts "compiling M"

  def foo, do: "foo"

  defmodule M do
    IO.puts "compiling #{inspect __MODULE__}"
    def bar, do: "bar"
  end
end

IO.puts "Hello"
```

---

# Modules (7)

```
# mod.ex
defmodule M do
  IO.puts "compiling M"

  def foo, do: "foo"

  defmodule M do
    IO.puts "compiling #{inspect __MODULE__}"
    def bar, do: "bar"
  end
end

IO.puts "Hello"
```

```
λ elixirc mod.ex
compiling M
compiling M.M
Hello
Compiled mod.ex
```

---

# Modules (8)

The module namespace is flat. Nested modules are just a syntactic convenience.

```
iex(1)> M.foo
"foo"

iex(2)> M.M.bar
"bar"
```

---

# Modules (8)

The module namespace is flat. Nested modules are just a syntactic convenience.

```
iex(1)> M.foo
"foo"

iex(2)> M.M.bar
"bar"
```

Alternatively,

```
defmodule M.M do  # same thing
  def bar do
    ...
  end
end
```

---

# Functions (1)

Functions are identified by their _name_ and _arity_.

```
defmodule Math do
  def square do
    x = :random.uniform(20)
    square(x)
  end

  def square(x) do
    x * x
  end
end
```

---

# Functions (1)

Functions are identified by their _name_ and _arity_.

```
defmodule Math do
  def square do
    x = :random.uniform(20)
    square(x)
  end

  def square(x) do
    x * x
  end
end
```

```
iex(1)> Math.__info__ :functions
[square: 0, square: 1]

iex(2)> Math.square
121
iex(3)> Math.square 5
25
```

---

# Functions (2)

Functions can have multiple clauses.

```
def capture_io(fun) do
  do_capture_io(:standard_io, [], fun)
end

def capture_io(device, fun) when is_atom(device) do
  capture_io(map_dev(device), [], fun)
end

def capture_io(input, fun) when is_binary(input) do
  capture_io(:standard_io, [input: input], fun)
end

def capture_io(device, input, fun) when is_binary(input) do
  capture_io(map_dev(device), [input: input], fun)
end
```

---

# Functions (3)

Functions can have multiple clauses.

```
capture_io(fn -> ... end)
# == capture_io(:standard_io, [], fn -> ... end)

capture_io(:stderr, fn -> ... end)
# == capture_io(:standard_error, [], fn -> ... end)

capture_io("123\n", fn -> ... end)
# == capture_io(:standard_io, [input: "123\n"], fn -> ... end)
```

---

# Functions (4)

It is also possible to use short syntax for `do` blocks.

```
defp map_dev(:stdio),  do: :standard_io
defp map_dev(:stderr), do: :standard_error
defp map_dev(other),   do: other
```

```
defp hex2dec(n) when n in ?0..?9, do: n - ?0
defp hex2dec(n) when n in ?A..?F, do: n - ?A + 10
defp hex2dec(n) when n in ?a..?f, do: n - ?a + 10
```

---

# Functions (4)

It is also possible to use short syntax for `do` blocks.

```
defp map_dev(:stdio),  do: :standard_io
defp map_dev(:stderr), do: :standard_error
defp map_dev(other),   do: other
```

```
defp hex2dec(n) when n in ?0..?9, do: n - ?0
defp hex2dec(n) when n in ?A..?F, do: n - ?A + 10
defp hex2dec(n) when n in ?a..?f, do: n - ?a + 10
```

In general,

```
<something> do
  expr1
  expr2
  ...
end
# ==
<something> do: (expr1; expr2; ...)
```

---

# Functions (5)

Functions can be public (exported) and private.

```
defmodule M do
  def public_fn(arg) do
    IO.puts "Hello #{cap arg}"
    IO.puts "I am a public 1-argument function!"
  end

  defp cap(arg) when is_binary(arg) do
    String.capitalize arg
  end
end
```

```
iex(1)> M.public_fn "boy"
Hello Boy
I am a public 1-argument function!
:ok

iex(2)> M.cap "boy"
** (UndefinedFunctionError) undefined function: M.cap/1
```

---

# Functions (6)

Using docstrings is a great way to document code.

```
demodule Kernel
  @moduledoc """
  `Kernel` provides the default macros and functions
  Elixir imports into your environment.
  """

  @doc """
  Invokes the given `fun` from `module` with the array
  of arguments `args`.

  ## Examples

      iex> apply(Enum, :reverse, [[1, 2, 3]])
      [3,2,1]

  """
  def apply(module, fun, args) do
    ...
  end
```

---

# Functions (7)

Inspect docs in IEx.

```
iex(1)> h Kernel.apply/3
* def apply(module, fun, args)

Invokes the given `fun` from `module` with the array
of arguments `args`.

## Examples

    iex> apply(Enum, :reverse, [[1, 2, 3]])
    [3,2,1]

:ok
```

---

# Functions (8)

Generate HTML documentation from the source.

![apply docs](data/apply_screen.png)

---

# Recursion (1)

Elixir wouldn't be a functional language if it didn't rely on recursion.

```
defmodule L do
  def count(lst, elem) when is_list(lst) do
    do_count(lst, elem, 0)
  end

  defp do_count([elem|t], elem, cnt) do
    do_count(t, elem, cnt+1)
  end

  defp do_count([_|t], elem, cnt) do
    do_count(t, elem, cnt)
  end

  defp do_count([], _, cnt) do
    cnt
  end
end
```

---

# Recursion (2)

```
L.count ["a", "b", "c", "a"], "a"  # 2
L.count ["a", "b", "c", "a"], "d"  # 0
L.count [], "a"                    # 0
```

---

# Recursion (2)

```
L.count ["a", "b", "c", "a"], "a"  # 2
L.count ["a", "b", "c", "a"], "d"  # 0
L.count [], "a"                    # 0
```

But you will write a lot less code like this in Elixir. `Enum` and `Stream` are going to be your friends.

```
Enum.count ["a", "b", "c", "a"], &1 == "a"  # 2

Enum.each 1..5, fn _ -> IO.write "Hello" end
#=> HelloHelloHelloHelloHello:ok

Stream.repeatedly(fn -> 1 end) |> Enum.take(10)
#=> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

Stream.cycle([0,1,2,1]) |> Stream.map(-&1) |> Enum.take(13)
#=> [0, -1, -2, -1, 0, -1, -2, -1, 0, -1, -2, -1, 0]
```

---

# Tail recursion (1)

Elixir inherits automatic tail call optimization from Erlang.

```
defmodule Inf do
  def loop(0), do: :ok
  def loop(:forever), do: loop(:forever)
  def loop(n), do: (IO.puts n; loop n-1)
end
```

```
iex(1)> Inf.loop 2
2
1
:ok

iex(2)> Inf.loop :forever
# ...
```

---

# Tail recursion (2)

Common idiom – receive loop.

```
def loop(state) do
  receive do
    <pattern1> ->
      # ... do something
      updated_state = ...
      loop(updated_state)

    <pattern2> ->
      # ... do something else
      loop(state)

    <exit-pattern> ->
      :ok  # terminate recursion
  end
end
```

---

# Tail recursion (3)

Imperative analogue.

```javascript
var state = ...;
while (true) {
  // ... do something
  // ... maybe update state
  state = update(state);

  some_global_var = ...;

  // ...

  other_unrelated_var = ...;

  if (/*terminating condition*/) {
    break;
  }
}
```

---

class: middle

# > `Enum` and `Stream` modules

---

class: middle

# Records and protocols

---

# Records (1)

A record is a tagged tuple with one or more "fields".

```
iex(1)> { Rec, 123, "hello" }
{Rec, 123, "hello"}

iex(2)> { Range, 0, 1 }
0..1

iex(3)> inspect -1..-4, raw: true
"{Range, -1, -4}"
```

---

# Records (2)

Records are usually backed by record modules.

```
defrecord Movie, name: "", year: 0, genres: []

m = Movie.new()
#=> Movie[name: "", year: 0, genres: []]

m = Movie.new(name: "Up", year: 2009)
#=> Movie[name: "Up", year: 2009, genres: []]

m = Movie[name: "Up", year: 2009]
#=> Movie[name: "Up", year: 2009, genres: []]

inspect m, raw: true
#=> "{Movie, \"Up\", 2009, []}"

{ Movie, "Kill Bill", 2003, ["action"] }
#=> Movie[name: "Kill Bill", year: 2003, genres: ["action"]]
```

---

# Records (3)

Records can be pattern-matched too.

```
defmodule R do
  defrecord Movie, name: "", year: 0, genres: []

  def review(Movie[name: "Up"]) do
    "Good movie"
  end

  def review(Movie[year: year]) when year < 2000 do
    "Great movie"
  end

  def review(Movie[]) do
    "Meh"
  end
end
```

---

# Records (4)

```
R.review R.Movie.new(name: "Up")
#=> "Good movie"

R.review R.Movie.new(name: "Django", year: 1966)
#=> "Great movie"

R.review R.Movie.new(name: "Oblivion", year: 2013)
#=> "Meh"
```

---

# Records (5)

Record access is polymorphic.

```
iex> { :ok, stat } = File.stat "."
iex> stat
File.Stat[size: 510, type: :directory, access: :read_write,
 atime: {{2013, 7, 27}, {9, 3, 41}},
 mtime: {{2013, 7, 27}, {9, 12, 13}},
 ctime: {{2013, 7, 27}, {9, 12, 13}},
 mode: 16877, links: 15, major_device: 16777220, minor_device: 0,
 inode: 5340338, uid: 501, gid: 20]
iex> stat.type
:directory

###

iex> defrecord Dummy, type: "safe"
iex> d = Dummy[]
iex> d.type
"safe"
```

---

# Protocols (1)

Protocols define behavior that is decoupled from implementation.

```
defprotocol Inspect do
 def inspect(thing, opts)
end
```

---

# Protocols (1)

Protocols define behavior that is decoupled from implementation.

```
defprotocol Inspect do
 def inspect(thing, opts)
end
```

Implementations are defined independently for each type.

```
defimpl Inspect, for: Number do
  def inspect(thing, _opts) when is_integer(thing) do
    integer_to_binary(thing)
  end
end

inspect 123
#=> "123"
```

---

# Protocols (2)

The decoupled nature of protocols allows for painless extension.

```
inspect Movie[]
#=> "Movie[name: \"\", year: 0, genres: []]"

defimpl Inspect, for: Movie do
  def inspect(Movie[name: name, year: year], _opts) do
    "This is a movie from the great era of #{year}s.
     It is called '#{name}'"
  end
end

inspect Movie[name: "Django", year: 1960]
#=> "This is a movie from the great era of 1960s.
#=>  It is called 'Django'"
```

---

# Protocols (3)

Access protocol.

```
lst = [a: 1, b: 2, c: 3]
lst[:c]  #=> 3

defimpl Access, for: List do
  def access([], _), do: :empty
  def access(lst, key) do
    case List.keyfind(lst, key, 1) do
      { val, ^key } -> val
      nil           -> :not_found
    end
  end
end

lst[:c]  #=> :not_found
lst[3]   #=> :c
```

---

class: middle

# > jazz – JSON library for Elixir

[github.com/meh/jazz](https://github.com/meh/jazz)

---

# jazz (1)

Easily encode and decode JSON.

```
json = JSON.encode!([name: "Alex", age: 23])
IO.puts json
#=> {"name":"Alex","age":23}

JSON.decode!(json)
#=> [{"name", "Alex"}, {"age", 23}]

JSON.decode!(json, keys: :atoms)
#=> [name: "Alex", age: 23]

defrecord Person, name: "", age: 0

JSON.encode!(Person[name: "Alex", age: 23])
|> IO.puts
#=> {"name":"Alex","age":23}

JSON.decode!(json, as: Person)
#=> Person[name: "Alex", age: 23]
```

---

# jazz (2)

Protocols allow for painless extension.

```
defimpl JSON.Encoder, for: HashDict do
  def to_json(self, options), do: HashDict.to_list(self)
end

defimpl JSON.Decoder, for: HashDict do
  def from_json({ _, parsed, _ }), do: HashDict.new(parsed)
end

json =
  HashDict.new(movie: "Up", year: 2009, genre: "animation")
  |> JSON.encode!
IO.puts json
#=> {"genre":"animation","movie":"Up","year":2009}

JSON.decode!(json, as: HashDict)
#=> #HashDict<[{"genre", "animation"},
               {"movie", "Up"},
               {"year", 2009}]>
```

---

class: middle

# Macros

---

# Macros: motivation

Classical example of a conditional with macros.

```
def unless(condition, [do: t_clause, else: f_clause]) do
  if !condition do
     t_clause
  else
     f_clause
  end
end

unless 1 == 2, do: IO.puts("1 != 2"), else: IO.puts("1 == 2")
# 1 != 2
# 1 == 2

unless 1 == 2 do
  IO.puts "1 != 2"
else
  IO.puts "1 == 2"
end
# 1 != 2
# 1 == 2
```

---

# Macros: functional solution

Maybe we could still use a plain function for this?

```
def unless(condition, t_clause, f_clause) do
  if !condition do
     t_clause.()
  else
     f_clause.()
  end
end

unless 1 == 2,
       fn -> IO.puts("1 != 2") end,
       fn -> IO.puts("1 == 2") end
#=> 1 != 2
```

---

# Macros: real solution

But macros are way more awesome.

```
defmacro unless(condition, [do: block, else: else_block]) do
  quote do
    if !unquote(condition) do
      unquote(block)
    else
      unquote(else_block)
    end
  end
end

unless 1 == 2 do
  IO.puts "1 != 2"
else
  IO.puts "1 == 2"
end
#=> 1 != 2
```

---

class: middle

# > Monadic

[github.com/sasa1977/monadic](https://github.com/sasa1977/monadic)

---

# Monadic (1)

A library that provides a set of control flow primitives, Haskell-style.

Error: stops evaluation if an error is encountered.

```
monadic :error do
  1
  2
  3
end == 3

monadic :error do
  some_fun(...)
  :error
  another_fun(...)
end == :error
```

---

# Monadic (2)

Last: stores the result of each expression in a variable.

```
monadic last: last do
  :sets.new
  :sets.add_element(:a, last)
  :sets.add_element(:b, last)
  :sets.add_element(:c, last)
  :sets.to_list(last)
end

last == [:a, :b, :c]
```

---

# Monadic (3)

Combine: multiple "monads" in the same context.

```
monadic combine: [:error, :last] do
  1
  _last + 2
  :error
  _last + 3
end == :error

_last == 3    # the result of the last successful operation
```
---

class: middle

# > `ExUnit`: unit testing framework

---

# `ExUnit`: unit testing framework

Provides the `assert` macro which you are going to use 90% of the time.

```
defmodule AssertTest do
  use ExUnit.Case

  test "comparison", do: assert 1 == 2

  test "match", do: assert "abc" <> _ = "bcd"

  test "boolean", do: assert !(:atoms_are_truthy)
end
```

---

# `assert` macro (1)

```
  test "boolean", do: assert !(:atoms_are_truthy)
```

```
  1) test boolean (AssertTest)
     ** (ExUnit.ExpectationError)
          expected: !:atoms_are_truthy
             to be: true
       instead got: false
     at assert.ex:15
```

---

# `assert` macro (2)

```
  test "comparison", do: assert 1 == 2
```

```
  2) test comparison (AssertTest)
     ** (ExUnit.ExpectationError)
                  expected: 1
       to be equal to (==): 2
     at assert.ex:7
```

---

# `assert` macro (3)

```
  test "match", do: assert "abc" <> _ = "bcd"
```

```
  3) test match (AssertTest)
     ** (ExUnit.ExpectationError)
                   expected: "bcd"
       to match pattern (=): "abc" <> _
     at assert.ex:11
```

---

class: middle

# Writing macros

---

class: middle

# Values in Elixir (terms)

---

# Built-in types (1)

## Number

```
1 + 2     # 3
1 / 2     # 0.5
0xF       # 15
010       # 8
0b1010    # 10
```

## Atom

```
:atom
:hello == :"hello"   # true
:hello == :bye       # false
:"M@dnés$"           # :"M@dnés$"
```

---

# Built-in types (2)

## Special atoms

```
# these expressions are all `true`
false == :false
true == :true
nil == :nil
is_boolean(:true)
is_boolean(:false)

# only nil and false are "falsey"
!nil    # == true
!false  # == true
!5      # == false
```

---

# Built-in types (3)

## List

```
[]
[1 | [2 | []]]  # same as [1, 2]
[:a, 11, [true, []]]
```

## Tuple

```
{}
{ :ok, [1, 2, 3] }
{ :tagged, :tuple, { :with, [:some, :payload] } }
[{:a, 1}, {:b, 2}, {:c, 3}]
```

---

# Built-in types (4)

## Keyword list

These are just lists of tuples:

```
iex(1)> [{:a, 1}, {:b, 2}]
[a: 1, b: 2]

iex(2)> [hello: :world]
[hello: :world]

iex(3)> inspect([hello: :world], raw: true)
"[{:hello, :world}]"

iex(4)> inspect(key: :value)
"[key: :value]"
```

---

# Built-in types (5)

## String (binary)

```
"elixir"
<<"elixir">>   # same thing

<<1,2,3,4,5>>  # 5 bytes

<<1::size(1), 2::size(2), 3::size(2)>>
# == <<27::size(5)>> (5 bits)
# because 0b11011 == 27
```

`<<"Binaries">>` in Erlang are UTF-8 encoded `"strings"` in Elixir.

---

# Built-in types (6)

* `pid`
```
iex(1)> pid = spawn fn -> IO.puts "Hello world" end
#PID<0.41.0>
Hello world
```
* `reference`
```
iex(2)> ref = make_ref()
#Reference<0.0.0.58>
```
* `port`

We'll look at `pid` later.

---

# Built-in types (recap)

1. number
1. atom
1. list
1. tuple
1. binary
1. pid
1. reference
1. port

Everything else is built on top of those.

---

# Serializing terms

Every term is automatically serializable.

.invisible[Can store any term in a database.]

.invisible[Can send any term on the wire.]

---

# Serializing terms

Every term is automatically serializable.

Can store any term in a database.

.invisible[Can send any term on the wire.]

---

# Serializing terms

Every term is automatically serializable.

Can store any term in a database.

Can send any term on the wire.

---

# Serializing terms

Every term is automatically serializable.

Can store any term in a database.

Can send any term on the wire.

```
iex(1)> bin = term_to_binary {[:hello, "my dear"], 123,
                    HashDict.new(a: 1, b: 2, c: "d"), [{}] }
<<131, 104, 4, 108, 0, 0, 0, 2, 100, 0, 5, 104, 101, 108, ...>>

iex(2)> binary_to_term bin
{[:hello, "my dear"], 123, #HashDict<[a: 1, b: 2, c: "d"]>, [{}]}

iex(3)> inspect HashDict.new(a: 1, b: 2, c: "d"), raw: true
"{HashDict, 3, [[:a | 1], [:b | 2], [:c | \"d\"]]}"
```

---

class: middle

# Using functions and modules

---

# Built-in functions (1)

## Strings

```
iex(1)> a = "ß"
"ß"
iex(2)> byte_size a   # same as byte_size(a)
2
iex(3)> binary_to_list a
[195, 159]
iex(4)> << a, b >> = a
"ß"
iex(5)> a
195
iex(6)> b
159
```

---

# Built-in functions (2)

## Modules

```
iex(1)> String.codepoints "straße"
["s", "t", "r", "a", "ß", "e"]
iex(2)> String.slice "straße", 3, 3
"aße"

iex(3)> length [1, 2, 3]
3
iex(4)> Kernel.length([1, 2, 3])
3

iex(5)> Record. # <TAB>
deffunctions/2    defmacros/4       deftypes/3
extract/2         import/2
```

---

class: middle

# How to get started

---

class: middle

# IEx – interactive shell

---

# Using IEx

```
λ iex
Erlang R16B (erts-5.10.1) [source] [64-bit] ...
Interactive Elixir (0.10.1-dev) - press Ctrl+C ...
iex(1)> "Hello world!"
"Hello world!"

iex(2)> 1 == 2
false

iex(3)> Enum.each 1..5, fn(x) ->
...(3)>   IO.puts "I got #{x}"
...(3)> end
I got 1
I got 2
I got 3
:ok
```

---

# Inspecting (1)

```
iex(1)> IEx.Helpers. # <TAB>
c/2              cd/1             flush/0          h/0
h/1              import_file/1    l/1              ls/1
m/0              pwd/0            r/0              r/1
s/1              t/1              v/0              v/1

iex(2)> pwd
/Users/alco/Dropbox/home/projects/elixir-talk
:ok

iex(3)> h m
* def m()

Prints the list of all loaded modules with paths
to their corresponding .beam files.

:ok
```

---

# Inspecting (2)

```
iex(1)> h String
#  String

A String in Elixir is a UTF-8 encoded binary.
[...]

iex(2)> h List.wrap/1
* def wrap(list)

Wraps the argument in a list.
If the argument is already a list, returns the list.
If the argument is nil, returns an empty list.

## Examples
[...]
:ok
```

---

# Inspecting (3)

## Macros lurking

```
iex(1)> String.split/1
** (UndefinedFunctionError) undefined function:
                            String.split/0

iex(2)> String.split() / 1
** (UndefinedFunctionError) undefined function:
                            String.split/0

iex(3)> h h/1
* defmacro h(other)

Prints the documentation for the given module
or for the given function/arity pair.
```

---

class: middle

# The future

---

# The future

The future looks bright for Elixir, but I'm more interested in the present.

Join the community and start hacking!

Everyone can contribute!

---

class: center, middle

# Thanks!

<br/>

<big>Alexei Sholik</big>
<pre>[@true_droid](https://twitter.com/true_droid)</pre>
<pre>[github.com/alco](https://github.com/alco)</pre>

<br/><br/><br/>

![img](data/logo.png)
<pre>[elixir-lang.org](http://elixir-lang.org) | [tryelixir.org](http://tryelixir.org/)</pre>

    </textarea>

    <div style="font-size: 0; z-index: 10; position: fixed">
      <button id="but-font-larger">+</button>
      <button id="but-font-smaller">-</button>
    </div>

    <script src="data/remark.js" type="text/javascript"></script>
    <script src="data/ui.js" type="text/javascript"></script>
  </body>
</html>
